using System;
using System.Collections.Generic;

using TextMateSharp.Themes;

namespace TextMateSharp.Internal.Grammars
{
    public class AttributedScopeStack
    {
        public AttributedScopeStack Parent { get; private set; }
        public string ScopePath { get; private set; }
        public int TokenAttributes { get; private set; }
        private List<string> _cachedScopeNames;

        // Precomputed, per-node hash code (persistent structure => safe as long as instances are immutable)
        private readonly int _hashCode;

        public AttributedScopeStack(AttributedScopeStack parent, string scopePath, int tokenAttributes)
        {
            Parent = parent;
            ScopePath = scopePath;
            TokenAttributes = tokenAttributes;
            _hashCode = ComputeHashCode(parent, scopePath, tokenAttributes);
        }

        private static bool StructuralEquals(AttributedScopeStack a, AttributedScopeStack b)
        {
            while (true)
            {
                if (a == b)
                {
                    return true;
                }

                if (a == null || b == null)
                {
                    // End of list reached only for one
                    return false;
                }

                if (!string.Equals(a.ScopePath, b.ScopePath, StringComparison.Ordinal) ||
                    a.TokenAttributes != b.TokenAttributes)
                {
                    return false;
                }

                // Go to previous pair
                a = a.Parent;
                b = b.Parent;
            }
        }

        private static bool Equals(AttributedScopeStack a, AttributedScopeStack b)
        {
            if (a == b)
            {
                return true;
            }
            if (a == null || b == null)
            {
                return false;
            }
            return StructuralEquals(a, b);
        }

        public override bool Equals(object other)
        {
            if (other is AttributedScopeStack attributedScopeStack)
                return Equals(this, attributedScopeStack);

            return false;
        }

        public override int GetHashCode()
        {
            return _hashCode;
        }

        private static int ComputeHashCode(AttributedScopeStack parent, string scopePath, int tokenAttributes)
        {
            unchecked
            {
                int hash = parent?._hashCode ?? 17;
                hash = (hash * 31) + tokenAttributes;

                int scopeHashCode;
                if (scopePath == null)
                {
                    scopeHashCode = 0;
                }
                else
                {
                    scopeHashCode = StringComparer.Ordinal.GetHashCode(scopePath);
                }

                hash = (hash * 31) + scopeHashCode;

                return hash;
            }
        }

        static bool MatchesScope(string scope, string selector)
        {
            if (scope == null || selector == null)
            {
                return false;
            }

            int selectorLen = selector.Length;
            int scopeLen = scope.Length;

            if (scopeLen == selectorLen)
                return string.Equals(scope, selector, StringComparison.Ordinal);

            // scope must be longer than selector and have a '.' immediately after the selector prefix
            if (scopeLen > selectorLen && scope[selectorLen] == '.')
                return string.CompareOrdinal(scope, 0, selector, 0, selectorLen) == 0;

            return false;
        }

        static bool Matches(AttributedScopeStack target, List<string> parentScopes)
        {
            if (parentScopes == null)
            {
                return true;
            }

            int len = parentScopes.Count;
            int index = 0;
            string selector = parentScopes[index];

            while (target != null)
            {
                if (MatchesScope(target.ScopePath, selector))
                {
                    index++;
                    if (index == len)
                    {
                        return true;
                    }
                    selector = parentScopes[index];
                }
                target = target.Parent;
            }

            return false;
        }

        public static int MergeAttributes(
            int existingTokenAttributes,
            AttributedScopeStack scopesList,
            BasicScopeAttributes basicScopeAttributes)
        {
            if (basicScopeAttributes == null)
            {
                return existingTokenAttributes;
            }

            FontStyle fontStyle = FontStyle.NotSet;
            int foreground = 0;
            int background = 0;

            if (basicScopeAttributes.ThemeData != null)
            {
                // Find the first themeData that matches
                List<ThemeTrieElementRule> themeDataList = basicScopeAttributes.ThemeData;
                for (int i = 0; i < themeDataList.Count; i++)
                {
                    ThemeTrieElementRule themeData = themeDataList[i];
                    if (Matches(scopesList, themeData.parentScopes))
                    {
                        fontStyle = themeData.fontStyle;
                        foreground = themeData.foreground;
                        background = themeData.background;
                        break;
                    }
                }
            }

            return EncodedTokenAttributes.Set(
                existingTokenAttributes,
                basicScopeAttributes.LanguageId,
                basicScopeAttributes.TokenType,
                null,
                fontStyle,
                foreground,
                background);
        }

        private static AttributedScopeStack Push(AttributedScopeStack target, Grammar grammar, string scopePath)
        {
            ReadOnlySpan<char> remaining = scopePath.AsSpan();

            // Use while(true) instead of while(remaining.Length > 0) to match
            // StringSplitOptions.None behavior: if the string ends with a space, the final
            // slice produces an empty span, and we must still push that empty segment
            // (e.g. "a b " => push "a", "b", "")
            while (true)
            {
                int spaceIndex = remaining.IndexOf(' ');
                if (spaceIndex < 0)
                {
                    target = PushSingleScope(target, grammar, GetScopeSlice(scopePath, remaining));
                    break;
                }

                target = PushSingleScope(target, grammar, GetScopeSlice(scopePath, remaining.Slice(0, spaceIndex)));
                remaining = remaining.Slice(spaceIndex + 1);
            }
            return target;
        }

        private static string GetScopeSlice(string scopePath, ReadOnlySpan<char> slice)
        {
            if (slice.IsEmpty)
            {
                return string.Empty;
            }

            if (slice.Length == scopePath.Length)
            {
                return scopePath;
            }

            return slice.ToString();
        }

        private static AttributedScopeStack PushSingleScope(AttributedScopeStack target, Grammar grammar, string scope)
        {
            BasicScopeAttributes rawMetadata = grammar.GetMetadataForScope(scope);
            int metadata = AttributedScopeStack.MergeAttributes(target.TokenAttributes, target, rawMetadata);
            return new AttributedScopeStack(target, scope, metadata);
        }

        public AttributedScopeStack PushAtributed(string scopePath, Grammar grammar)
        {
            if (scopePath == null)
            {
                return this;
            }
            if (grammar == null) throw new ArgumentNullException(nameof(grammar));

            if (scopePath.IndexOf(' ') >= 0)
            {
                // there are multiple scopes to push
                return Push(this, grammar, scopePath);
            }
            // there is a single scope to push - avoid List allocation
            return PushSingleScope(this, grammar, scopePath);
        }

        public List<string> GetScopeNames()
        {
            if (_cachedScopeNames == null)
            {
                _cachedScopeNames = GenerateScopes(this);
            }
            return _cachedScopeNames;
        }

        private static List<string> GenerateScopes(AttributedScopeStack scopesList)
        {
            // First pass: count depth to pre-size the array
            int depth = 0;
            AttributedScopeStack current = scopesList;
            while (current != null)
            {
                depth++;
                current = current.Parent;
            }

            // Second pass: fill backwards directly to avoid a Reverse() call
            string[] scopes = new string[depth];
            current = scopesList;
            for (int i = depth - 1; i >= 0; i--)
            {
                scopes[i] = current.ScopePath;
                current = current.Parent;
            }

            // Construct list from the correctly-ordered array
            return new List<string>(scopes);
        }
    }
}